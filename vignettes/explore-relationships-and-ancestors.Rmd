---
title: "Explore Relationships and Ancestors"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Explore Relationships and Ancestors}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(chariot)
library(tidyverse)
```

There are 3 different types of relationships represented in 
the Concept Relationship table depending on whether they are 
hierarchical and if they define ancestry. 

```sql
SELECT DISTINCT 
  is_hierarchical,
  defines_ancestry
FROM omop_vocabulary.relationship
```

```{r}
relationship_types <- 
  queryAthena(sql_statement = 
                "
                SELECT DISTINCT 
                  is_hierarchical,
                  defines_ancestry
                FROM omop_vocabulary.relationship
                ")
relationship_types
```

For each of the above types, any association with select 
controlled vocabularies is derived. 

```{r}
target_vocabularies <- c("SNOMED", "LOINC", 
                         "RxNorm", "RxNorm Extension", 
                         "HemOnc", "ATC")
output <- list()
for (i in 1:nrow(relationship_types)) {
  relationship_type <- 
    relationship_types %>%
    filter(row_number() == i)
  
  conn <- connectAthena()
  staging_table <- pg13::write_staging_table(conn = conn, 
                                             schema = "patelm9",
                                             data = relationship_type,
                                             drop_existing = TRUE,
                                             drop_on_exit = FALSE)
  
  output[[i]] <- list()
  for (j in seq_along(target_vocabularies)) {
  
    target_vocabulary <- target_vocabularies[j]
    
    sql_statement <-
      SqlRender::render(
        "
        SELECT 
          c.vocabulary_id,
          c.concept_class_id AS concept_class_id_1,
          c2.concept_class_id AS concept_class_id_2,
          r.relationship_id,
          r.is_hierarchical,
          r.defines_ancestry,
          ca.min_levels_of_separation,
          ca.max_levels_of_separation
        FROM patelm9.@staging_table t 
        INNER JOIN omop_vocabulary.relationship r 
        ON t.is_hierarchical = r.is_hierarchical 
            AND t.defines_ancestry = r.defines_ancestry 
        INNER JOIN omop_vocabulary.concept_relationship cr 
        ON cr.relationship_id = r.relationship_id 
        INNER JOIN omop_vocabulary.concept c 
        ON cr.concept_id_1 = c.concept_id  
        INNER JOIN omop_vocabulary.concept c2 
        ON cr.concept_id_2 = c2.concept_id 
        INNER JOIN omop_vocabulary.concept_ancestor ca 
        ON ca.ancestor_concept_id = cr.concept_id_1 
             AND ca.descendant_concept_id = cr.concept_id_2
        WHERE 
          c.invalid_reason IS NULL 
            AND c2.invalid_reason IS NULL 
            AND c.vocabulary_id IN ('@target_vocabulary') 
            AND c2.vocabulary_id IN ('@target_vocabulary')
            AND cr.invalid_reason IS NULL
        ",
        staging_table = staging_table,
        target_vocabulary = target_vocabulary
      )
    
    output[[i]][[j]] <-
      queryAthena(sql_statement = sql_statement)
    names(output[[i]])[j] <- target_vocabulary
  
  }
  
  pg13::drop_all_staging_tables(conn = conn, 
                                schema = "patelm9")
  dcAthena(conn = conn)
}
```






The valid relationship types amongst each of the most commonly employed 
target controlled vocabularies used in OMOP are derived. 

```{r}
target_vocabularies <- c("SNOMED", "LOINC", 
                         "RxNorm", "RxNorm Extension", 
                         "HemOnc", "ATC")
```

```sql
SELECT DISTINCT
  c.vocabulary_id,
  c.concept_class_id AS concept_class_id_1,
  c2.concept_class_id AS concept_class_id_2,
  r.is_hierarchical,
  r.defines_ancestry
FROM omop_vocabulary.concept c 
INNER JOIN omop_vocabulary.concept_relationship cr 
ON cr.concept_id_1 = c.concept_id 
INNER JOIN omop_vocabulary.concept c2 
ON cr.concept_id_2 = c2.concept_id
LEFT JOIN omop_vocabulary.relationship r 
ON r.relationship_id = cr.relationship_id
WHERE 
  c.invalid_reason IS NULL
    AND c.vocabulary_id IN ('@target_vocabulary') 
    AND c2.invalid_reason IS NULL 
    AND c2.vocabulary_id IN ('@target_vocabulary')
    AND cr.invalid_reason IS NULL;
```

```{r,cache=TRUE}
output <- list()
for (i in seq_along(target_vocabularies)) {
  target_vocabulary <- target_vocabularies[i]
  sql_statement <- 
    SqlRender::render(
      "
      SELECT DISTINCT
        c.vocabulary_id,
        c.concept_class_id AS concept_class_id_1,
        c2.concept_class_id AS concept_class_id_2,
        r.is_hierarchical,
        r.defines_ancestry
      FROM omop_vocabulary.concept c 
      INNER JOIN omop_vocabulary.concept_relationship cr 
      ON cr.concept_id_1 = c.concept_id 
      INNER JOIN omop_vocabulary.concept c2 
      ON cr.concept_id_2 = c2.concept_id
      LEFT JOIN omop_vocabulary.relationship r 
      ON r.relationship_id = cr.relationship_id
      WHERE 
        c.invalid_reason IS NULL
          AND c.vocabulary_id IN ('@target_vocabulary') 
          AND c2.invalid_reason IS NULL 
          AND c2.vocabulary_id IN ('@target_vocabulary')
          AND cr.invalid_reason IS NULL;
      ",
      target_vocabulary = target_vocabulary
    )
  output[[i]] <-
    queryAthena(
      sql_statement = sql_statement
    )
}
```


